<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Avanzamento posa condotta – PNRR</title>

  <link rel="icon" href="data:,">

  <!-- Librerie esterne -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

  <style>
    /* ==========================================================
       1) TEMA E LAYOUT GENERALE
       ========================================================== */
    :root {
      --bg: #ffffff;
      --fg: #111;
      --muted: #666;
      --panel: #fff;
      --border: #ddd;
      --shadow: 0 8px 28px rgba(0, 0, 0, 0.12);
    }

    body {
      margin: 0;
      font-family: Arial, sans-serif;
      color: var(--fg);
      background: var(--bg);
    }

    header {
      padding: 10px 14px;
      border-bottom: 1px solid var(--border);
      background: #fff;
    }

    .topline {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .title {
      max-width: 1200px;
      line-height: 1.25;
      font-size: 14px;
    }

    .title b {
      font-size: 16px;
      display: block;
      margin-bottom: 4px;
    }

    .meta {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 6px;
      color: var(--muted);
      font-size: 12px;
    }

    .pill {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 10px;
      background: #f7f7f7;
    }

    .logos {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .logos img {
      height: 42px;
      width: auto;
      object-fit: contain;
      border: 1px solid #eee;
      border-radius: 10px;
      padding: 6px 8px;
      background: #fff;
    }

    #map {
      height: calc(100vh - 122px);
    }

    /* ==========================================================
       2) PANNELLO OVERLAY (tabella + filtri)
       ========================================================== */
    .overlay {
      position: absolute;
      top: 135px;
      right: 14px;
      width: min(760px, calc(100vw - 28px));
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow: hidden;
      z-index: 999;
    }

    .overlay-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: #fafafa;
      flex-wrap: wrap;
    }

    .overlay-header .h {
      font-weight: 700;
      font-size: 13px;
    }

    .overlay-header .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .overlay-header select,
    .overlay-header button {
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
    }

    .overlay-body {
      max-height: 55vh;
      overflow: auto;
      background: #fff;
    }

    #totalsRow {
      padding: 10px 12px;
      border-bottom: 1px solid #eee;
      font-size: 12px;
      background: #fff;
      position: sticky;
      top: 0;
      z-index: 3;
    }

    #totalsRow b {
      font-weight: 700;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    th,
    td {
      padding: 8px 8px;
      border-bottom: 1px solid #eee;
      text-align: right;
      white-space: nowrap;
    }

    th {
      position: sticky;
      top: 44px;
      background: #fff;
      z-index: 2;
      border-bottom: 1px solid var(--border);
    }

    td:first-child,
    th:first-child,
    td:nth-child(2),
    th:nth-child(2) {
      text-align: left;
    }

    .swatch {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      margin-right: 6px;
      vertical-align: middle;
    }

    .bar {
      height: 8px;
      background: #eee;
      border-radius: 999px;
      overflow: hidden;
      margin-top: 4px;
    }

    .bar > div {
      height: 100%;
      background: #444;
      width: 0%;
    }

    /* In modalità compatta mostriamo solo i totali, senza tabella. */
    .overlay.compact .overlay-body table {
      display: none;
    }

    .overlay.compact .overlay-body {
      max-height: none;
    }

    /* ==========================================================
       3) BARRA CAMBIO BASEMAP
       ========================================================== */
    .basebar {
      display: flex;
      gap: 0;
      border: 1px solid #d9d9d9;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
      background: #fff;
    }

    .basebar button {
      appearance: none;
      border: 0;
      background: #fff;
      padding: 6px 10px;
      font-size: 12px;
      line-height: 1;
      cursor: pointer;
      color: #222;
      border-right: 1px solid #e6e6e6;
    }

    .basebar button:last-child {
      border-right: 0;
    }

    .basebar button:hover {
      background: #f5f5f5;
    }

    .basebar button.active {
      background: #111;
      color: #fff;
    }

    /* Responsive mobile */
    @media (max-width: 720px) {
      .logos img {
        height: 34px;
      }

      #map {
        height: calc(100vh - 168px);
      }

      .overlay {
        top: 182px;
        left: 14px;
        right: 14px;
        width: auto;
      }
    }
  </style>
</head>

<body>
  <header>
    <div class="topline">
      <div class="title">
        <b>Schema irriguo Tidone – Avanzamento posa condotta</b>
        Piano Nazionale di Ripresa e Resilienza (PNRR). Missione 2 - Componente 4 - Investimento 4.3 - Investimenti nella resilienza dell'agrosistema irriguo per una migliore gestione delle risorse idriche - finanziato dall'Unione Europea - Next Generation EU. Intervento: Schema irriguo Tidone: interventi di risparmio idrico per il contrasto alla siccità e adeguamenti funzionali del sistema adduzione in sponda sinistra e destra Tidone: tronchi 1) Bruso - Rio; 2) da canale Tavernago - Tuna a lago delle Lische; 3) dal lago delle Lische a Tuna. Codice intervento: 08-05-5703-847. Decreto di concessione del contributo pubblico di finanziamento: Decreto MIPAAF - DISR 01 - Prot. 0484456 del 30/09/2022. Importo complessivo € 7.666.906,95. CUP G99J21006930005.
        <div class="meta">
          <span id="status" class="pill">caricamento…</span>
          <span id="updated" class="pill"></span>
          <span id="baseline" class="pill"></span>
        </div>
      </div>

      <div class="logos">
        <!-- Loghi istituzionali (facoltativi). -->
        <img src="assets/italiadomani.png" alt="Italia Domani">
        <img src="assets/masaf.png" alt="MASAF">
        <img src="assets/nextgenerationeu.png" alt="NextGenerationEU">
        <img src="assets/consorzio.png" alt="Consorzio">
      </div>
    </div>
  </header>

  <!-- Contenitore mappa Leaflet -->
  <div id="map"></div>

  <!-- Overlay con filtri, riepilogo e tabella -->
  <div class="overlay" id="overlay">
    <div class="overlay-header">
      <div class="h">Avanzamento per tronco</div>
      <div class="controls">
        <select id="filterTronco">
          <option value="">Tutti i tronchi</option>
        </select>
        <select id="filterDitta">
          <option value="">Tutte le ditte</option>
        </select>
        <button id="resetFilters">Reset</button>
        <button id="toggle">Comprimi</button>
      </div>
    </div>

    <div class="overlay-body">
      <div id="totalsRow">Totali: —</div>

      <table>
        <thead>
          <tr>
            <th>Tronco</th>
            <th>Ditta</th>
            <th>Tot (m)</th>
            <th>Posati (m)</th>
            <th>%</th>
            <th>Δ% dal 27/01</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>

  <script>
    (() => {
      "use strict";

      /* ========================================================
         A) CONFIGURAZIONE
         ======================================================== */
      const FILE_TRONCHI = "tronchi.geojson";
      const FILE_AVANZ = "avanzamento.json";

      // Se i tronchi sono disegnati con verso opposto alla progressiva reale,
      // lasciare true per invertire il lato di avanzamento.
      const REVERSE_PROGRESS = true;

      // Ordine visualizzazione tronchi e palette colori associata.
      const TRONCHI_ORDER = ["PV", "1", "2", "3-1", "3-2", "4", "5"];
      const PALETTE = ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#a65628", "#f781bf", "#999999"];

      // Cache buster per forzare refresh file locali.
      const CB = Date.now();

      /* ========================================================
         B) RIFERIMENTI DOM
         ======================================================== */
      const statusEl = document.getElementById("status");
      const updatedEl = document.getElementById("updated");
      const baselineEl = document.getElementById("baseline");
      const totalsEl = document.getElementById("totalsRow");

      const tbody = document.getElementById("tbody");
      const overlay = document.getElementById("overlay");
      const toggleBtn = document.getElementById("toggle");
      const filterTr = document.getElementById("filterTronco");
      const filterDi = document.getElementById("filterDitta");
      const resetBtn = document.getElementById("resetFilters");

      const setStatus = (text) => { statusEl.textContent = text; };
      const setUpdated = (text) => { updatedEl.textContent = text; };
      const setBaseline = (text) => { baselineEl.textContent = text; };

      /* ========================================================
         C) INIZIALIZZAZIONE MAPPA
         ======================================================== */
      const map = L.map("map");

      const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "&copy; OpenStreetMap contributors"
      });

      const carto = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
        attribution: "&copy; OpenStreetMap contributors & CARTO"
      });

      const esriSat = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        { attribution: "Tiles &copy; Esri" }
      );

      // Basemap di default all'avvio.
      carto.addTo(map);

      // Controllo custom compatto per cambiare basemap.
      const BaseBar = L.Control.extend({
        options: { position: "topleft" },
        onAdd() {
          const div = L.DomUtil.create("div", "basebar leaflet-bar");
          div.innerHTML = `
            <button type="button" data-base="carto" class="active" title="Carto Light">Carto</button>
            <button type="button" data-base="osm" title="OpenStreetMap">OSM</button>
            <button type="button" data-base="sat" title="Satellitare">Sat</button>
          `;

          L.DomEvent.disableClickPropagation(div);
          L.DomEvent.disableScrollPropagation(div);

          const setActive = (key) => {
            div.querySelectorAll("button").forEach((button) => {
              button.classList.toggle("active", button.dataset.base === key);
            });
          };

          const setBase = (key) => {
            [carto, osm, esriSat].forEach((layer) => map.removeLayer(layer));

            if (key === "osm") {
              osm.addTo(map);
            } else if (key === "sat") {
              esriSat.addTo(map);
            } else {
              carto.addTo(map);
            }

            setActive(key);
          };

          div.addEventListener("click", (event) => {
            const button = event.target.closest("button[data-base]");
            if (!button) return;
            setBase(button.dataset.base);
          });

          return div;
        }
      });

      map.addControl(new BaseBar());

      /* ========================================================
         D) FUNZIONI HELPER (parsing, formattazione, geometrie)
         ======================================================== */
      const getTroncoId = (properties) => properties?.tronco ?? properties?.Tronco ?? properties?.TRONCO ?? null;
      const getDitta = (properties) => properties?.ditta ?? properties?.Ditta ?? properties?.DITTA ?? "";
      const fmt = (value) => (Number(value) || 0).toFixed(2);

      function orderIndex(id) {
        const index = TRONCHI_ORDER.indexOf(String(id));
        return index === -1 ? 999 : index;
      }

      function colorForTronco(id) {
        const index = Math.max(0, orderIndex(String(id)));
        return PALETTE[index % PALETTE.length];
      }

      // Converte coordinate in numeri finiti per evitare errori nelle funzioni Turf.
      function toValidPoint(point) {
        if (!Array.isArray(point) || point.length < 2) return null;
        const lng = Number(point[0]);
        const lat = Number(point[1]);
        if (!Number.isFinite(lng) || !Number.isFinite(lat)) return null;
        return [lng, lat];
      }

      // Pulisce feature LineString/MultiLineString mantenendo solo coordinate valide.
      function sanitizeFeature(feature) {
        const geometry = feature?.geometry;
        if (!geometry) return null;

        if (geometry.type === "LineString") {
          const cleanCoordinates = (geometry.coordinates || []).map(toValidPoint).filter(Boolean);
          if (cleanCoordinates.length < 2) return null;
          return {
            ...feature,
            geometry: { type: "LineString", coordinates: cleanCoordinates }
          };
        }

        if (geometry.type === "MultiLineString") {
          const cleanParts = (geometry.coordinates || [])
            .map((line) => (line || []).map(toValidPoint).filter(Boolean))
            .filter((line) => line.length >= 2);

          if (cleanParts.length < 1) return null;

          return {
            ...feature,
            geometry: { type: "MultiLineString", coordinates: cleanParts }
          };
        }

        return null;
      }

      // Calcola punto avanzamento lungo il tronco da usare come marker.
      function progressPoint(feature, done, total) {
        const progressRatio = total > 0 ? Math.min(done / total, 1) : 0;
        const totalKm = turf.length(feature, { units: "kilometers" });
        if (!Number.isFinite(totalKm) || totalKm <= 0) {
          return { ok: false, perc: progressRatio };
        }

        const effectiveRatio = REVERSE_PROGRESS ? (1 - progressRatio) : progressRatio;
        const distanceKm = totalKm * effectiveRatio;

        try {
          const point = turf.along(feature, distanceKm, { units: "kilometers" });
          return { ok: true, perc: progressRatio, point };
        } catch {
          return { ok: false, perc: progressRatio };
        }
      }

      // Divide la geometria in due porzioni:
      // - segPosato  -> parte realizzata (tratteggiata)
      // - segResiduo -> parte da fare (linea piena)
      function splitSegments(feature, done, total) {
        const totalKm = turf.length(feature, { units: "kilometers" });
        if (!Number.isFinite(totalKm) || totalKm <= 0 || total <= 0) {
          return { segPosato: null, segResiduo: null };
        }

        const progressRatio = Math.min(done / total, 1);
        const doneKm = totalKm * progressRatio;

        try {
          if (!REVERSE_PROGRESS) {
            return {
              segPosato: turf.lineSliceAlong(feature, 0, doneKm, { units: "kilometers" }),
              segResiduo: turf.lineSliceAlong(feature, doneKm, totalKm, { units: "kilometers" })
            };
          }

          return {
            segPosato: turf.lineSliceAlong(feature, Math.max(totalKm - doneKm, 0), totalKm, { units: "kilometers" }),
            segResiduo: turf.lineSliceAlong(feature, 0, Math.max(totalKm - doneKm, 0), { units: "kilometers" })
          };
        } catch {
          return { segPosato: null, segResiduo: null };
        }
      }

      /* ========================================================
         E) STATO APPLICAZIONE
         ======================================================== */
      const layersByTronco = {}; // { troncoId: [leafletLayer, ...] }
      let rowsData = [];         // [{ id, ditta, tot, done, perc, col, feature }, ...]
      let baseDate = "";
      let baseMap = {};
      let compact = false;

      function clearLayers() {
        Object.values(layersByTronco).forEach((layers) => {
          layers.forEach((layer) => map.removeLayer(layer));
        });

        Object.keys(layersByTronco).forEach((key) => delete layersByTronco[key]);
      }

      /* ========================================================
         F) UI: COMPATTA / ESPANDI
         ======================================================== */
      toggleBtn.addEventListener("click", () => {
        compact = !compact;
        overlay.classList.toggle("compact", compact);
        toggleBtn.textContent = compact ? "Espandi" : "Comprimi";
      });

      /* ========================================================
         G) UI: FILTRI E RENDER TABELLA/TOTALI
         ======================================================== */
      function buildFilters() {
        const tronchi = Array.from(new Set(rowsData.map((row) => row.id)))
          .sort((a, b) => orderIndex(a) - orderIndex(b) || a.localeCompare(b));

        filterTr.innerHTML =
          `<option value="">Tutti i tronchi</option>` +
          tronchi.map((id) => `<option value="${id}">${id}</option>`).join("");

        const ditte = Array.from(new Set(rowsData.map((row) => row.ditta).filter(Boolean))).sort();
        filterDi.innerHTML =
          `<option value="">Tutte le ditte</option>` +
          ditte.map((name) => `<option value="${name}">${name}</option>`).join("");
      }

      function renderTable(filteredRows) {
        tbody.innerHTML = "";

        filteredRows.forEach((row) => {
          const baseDone = Number(baseMap[row.id] ?? 0);
          const deltaMeters = row.done - baseDone;
          const deltaPercent = row.tot > 0 ? (deltaMeters / row.tot) * 100 : 0;

          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td><span class="swatch" style="background:${row.col}"></span>${row.id}</td>
            <td>${row.ditta || ""}</td>
            <td>${fmt(row.tot)}</td>
            <td>${fmt(row.done)}</td>
            <td>
              ${row.perc.toFixed(1)}%
              <div class="bar"><div style="width:${Math.min(row.perc, 100).toFixed(1)}%"></div></div>
            </td>
            <td>${deltaPercent.toFixed(1)}%</td>
          `;

          tbody.appendChild(tr);
        });
      }

      function renderTotals(filteredRows) {
        const tronchiCount = new Set(filteredRows.map((row) => row.id)).size;
        const ditteCount = new Set(filteredRows.map((row) => row.ditta).filter(Boolean)).size;

        const totalMeters = filteredRows.reduce((sum, row) => sum + (Number(row.tot) || 0), 0);
        const doneMeters = filteredRows.reduce((sum, row) => sum + (Number(row.done) || 0), 0);

        const deltaMeters = filteredRows.reduce((sum, row) => {
          const baseDone = Number(baseMap[row.id] ?? 0);
          return sum + ((Number(row.done) || 0) - baseDone);
        }, 0);

        const totalPercent = totalMeters > 0 ? (doneMeters / totalMeters) * 100 : 0;
        const deltaPercent = totalMeters > 0 ? (deltaMeters / totalMeters) * 100 : 0;

        totalsEl.innerHTML = `
          <b>Tutti i tronchi</b> ·
          Tronchi: <b>${tronchiCount}</b> ·
          Ditte: <b>${ditteCount}</b> ·
          Tot: <b>${fmt(totalMeters)}</b> m ·
          Posati: <b>${fmt(doneMeters)}</b> m ·
          %: <b>${totalPercent.toFixed(1)}%</b> ·
          Δ% dal ${baseDate}: <b>${deltaPercent.toFixed(1)}%</b>
        `;
      }

      function applyFilters() {
        const selectedTronco = filterTr.value;
        const selectedDitta = filterDi.value;

        const filteredRows = rowsData.filter((row) => {
          const troncoMatch = !selectedTronco || row.id === selectedTronco;
          const dittaMatch = !selectedDitta || row.ditta === selectedDitta;
          return troncoMatch && dittaMatch;
        });

        // Aggiorna pannello dati.
        renderTotals(filteredRows);
        renderTable(filteredRows);

        // Aggiorna layer visibili in mappa.
        const visibleIds = new Set(filteredRows.map((row) => row.id));
        Object.entries(layersByTronco).forEach(([troncoId, layers]) => {
          const shouldShow = visibleIds.has(troncoId);
          layers.forEach((layer) => {
            if (shouldShow && !map.hasLayer(layer)) layer.addTo(map);
            if (!shouldShow && map.hasLayer(layer)) map.removeLayer(layer);
          });
        });
      }

      filterTr.addEventListener("change", applyFilters);
      filterDi.addEventListener("change", applyFilters);
      resetBtn.addEventListener("click", () => {
        filterTr.value = "";
        filterDi.value = "";
        applyFilters();
      });

      /* ========================================================
         H) CARICAMENTO DATI E DISEGNO
         ======================================================== */
      setStatus("caricamento…");

      Promise.all([
        fetch(`${FILE_TRONCHI}?cb=${CB}`).then((response) => {
          if (!response.ok) throw new Error(`tronchi.geojson HTTP ${response.status}`);
          return response.json();
        }),
        fetch(`${FILE_AVANZ}?cb=${CB}`).then((response) => {
          if (!response.ok) throw new Error(`avanzamento.json HTTP ${response.status}`);
          return response.json();
        })
      ])
        .then(([geo, avanz]) => {
          setStatus("dati caricati");
          setUpdated(`aggiornato: ${avanz._updated || "NON INDICATO nel JSON"}`);

          baseDate = avanz._baseline_date || "2026-01-27";
          baseMap = avanz._baseline_done || {};
          setBaseline(`baseline: ${baseDate}`);

          const cleanFeatures = (geo.features || []).map(sanitizeFeature).filter(Boolean);

          // Mappa dati JSON+GeoJSON in un dataset unificato per rendering tabella e mappa.
          rowsData = [];
          cleanFeatures.forEach((feature) => {
            const id = getTroncoId(feature.properties);
            if (!id) return;

            const datiAvanzamento = avanz[String(id)];
            if (!datiAvanzamento) return;

            const ditta = getDitta(feature.properties);
            const tot = Number(datiAvanzamento.tot) || 0;
            const done = Number(datiAvanzamento.done) || 0;
            const perc = tot > 0 ? (done / tot) * 100 : 0;
            const col = colorForTronco(id);

            rowsData.push({
              id: String(id),
              ditta,
              tot,
              done,
              perc,
              col,
              feature
            });
          });

          // Ordinamento richiesto: PV,1,2,3-1,3-2,4,5.
          rowsData.sort((a, b) => orderIndex(a.id) - orderIndex(b.id) || a.id.localeCompare(b.id));

          // Zoom automatico sull'estensione dei tronchi disponibili.
          const tmp = L.geoJSON({ type: "FeatureCollection", features: cleanFeatures }).addTo(map);
          if (cleanFeatures.length) map.fitBounds(tmp.getBounds());
          map.removeLayer(tmp);

          // Ridisegna tutti i layer tronco (residuo + posato + marker avanzamento).
          clearLayers();

          rowsData.forEach((row) => {
            const id = row.id;
            const feature = row.feature;
            const color = row.col;
            const ditta = row.ditta;

            layersByTronco[id] = layersByTronco[id] || [];

            const { segPosato, segResiduo } = splitSegments(feature, row.done, row.tot);

            // Segmento residuo (linea piena).
            if (segResiduo) {
              const layerResiduo = L.geoJSON(segResiduo, {
                style: { color, weight: 5, opacity: 1 }
              }).addTo(map);
              layersByTronco[id].push(layerResiduo);
            }

            // Segmento posato (linea tratteggiata).
            if (segPosato) {
              const layerPosato = L.geoJSON(segPosato, {
                style: { color, weight: 5, opacity: 1, dashArray: "10 8" }
              }).addTo(map);
              layersByTronco[id].push(layerPosato);
            }

            // Marker punto avanzamento.
            const result = progressPoint(feature, row.done, row.tot);
            if (result.ok && result.point) {
              const [lng, lat] = result.point.geometry.coordinates;
              const marker = L.circleMarker([lat, lng], {
                radius: 7,
                color,
                fillColor: color,
                fillOpacity: 1
              })
                .bindPopup(`
                  <b>Tronco ${id}</b><br>
                  ${ditta ? `<i>${ditta}</i><br>` : ""}
                  ${fmt(row.done)} / ${fmt(row.tot)} m<br>
                  ${(Math.min(row.done / (row.tot || 1), 1) * 100).toFixed(1)} %
                `)
                .addTo(map);

              layersByTronco[id].push(marker);
            }
          });

          // Prima renderizzazione UI.
          buildFilters();
          applyFilters();
        })
        .catch((error) => {
          console.error(error);
          setStatus("errore");
          alert(error.message || "Errore nel caricamento");
        });
    })();
  </script>
</body>
</html>
