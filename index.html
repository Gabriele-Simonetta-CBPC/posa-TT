<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Avanzamento posa condotta – PNRR</title>

<link rel="icon" href="data:,">

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

<style>
  :root{
    --bg:#ffffff;
    --fg:#111;
    --muted:#666;
    --panel:#fff;
    --border:#ddd;
    --shadow: 0 8px 28px rgba(0,0,0,.12);
  }
  body{ margin:0; font-family: Arial, sans-serif; color:var(--fg); background:var(--bg); }
  header{ padding:10px 14px; border-bottom:1px solid var(--border); background:#fff; }
  .topline{ display:flex; gap:12px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap; }
  .title{ max-width: 1200px; line-height: 1.25; font-size: 14px; }
  .title b{ font-size: 16px; display:block; margin-bottom:4px; }
  .meta{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:6px; color:var(--muted); font-size:12px; }
  .pill{ border:1px solid var(--border); border-radius:999px; padding:4px 10px; background:#f7f7f7; }
  .logos{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }
  .logos img{ height:42px; width:auto; object-fit:contain; border:1px solid #eee; border-radius:10px; padding:6px 8px; background:#fff; }
  #map{ height: calc(100vh - 122px); }

  .overlay{
    position:absolute;
    top:135px;
    right:14px;
    width:min(720px, calc(100vw - 28px));
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:14px;
    box-shadow:var(--shadow);
    overflow:hidden;
    z-index:999;
  }
  .overlay-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    padding:10px 12px;
    border-bottom:1px solid var(--border);
    background:#fafafa;
    flex-wrap:wrap;
  }
  .overlay-header .h{ font-weight:700; font-size:13px; }
  .overlay-header .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }
  .overlay-header select, .overlay-header button{
    border:1px solid var(--border);
    background:#fff;
    border-radius:10px;
    padding:6px 10px;
    font-size:12px;
    cursor:pointer;
  }
  .overlay-body{ max-height:55vh; overflow:auto; }

  table{ width:100%; border-collapse:collapse; font-size:12px; }
  th, td{ padding:8px 8px; border-bottom:1px solid #eee; text-align:right; white-space:nowrap; }
  th{ position:sticky; top:0; background:#fff; z-index:2; border-bottom:1px solid var(--border); }
  td:first-child, th:first-child, td:nth-child(2), th:nth-child(2){ text-align:left; }
  .swatch{ display:inline-block; width:10px; height:10px; border-radius:999px; margin-right:6px; vertical-align:middle; }
  .bar{ height:8px; background:#eee; border-radius:999px; overflow:hidden; margin-top:4px; }
  .bar > div{ height:100%; background:#444; width:0%; }

  @media (max-width:720px){
    .logos img{ height:34px; }
    #map{ height: calc(100vh - 168px); }
    .overlay{ top:182px; left:14px; right:14px; width:auto; }
  }
</style>
</head>

<body>
<header>
  <div class="topline">
    <div class="title">
      <b>Schema irriguo Tidone – Avanzamento posa condotta</b>
      Piano Nazionale di Ripresa e Resilienza (PNRR). Missione 2 - Componente 4 - Investimento 4.3 - Investimenti nella resilienza dell'agrosistema irriguo per una migliore gestione delle risorse idriche - finanziato dall'Unione Europea - Next Generation EU. Intervento: Schema irriguo Tidone: interventi di risparmio idrico per il contrasto alla siccità e adeguamenti funzionali del sistema adduzione in sponda sinistra e destra Tidone: tronchi 1) Bruso - Rio; 2) da canale Tavernago - Tuna a lago delle Lische; 3) dal lago delle Lische a Tuna. Codice intervento: 08-05-5703-847. Decreto di concessione del contributo pubblico di finanziamento: Decreto MIPAAF - DISR 01 - Prot. 0484456 del 30/09/2022. Importo complessivo € 7.666.906,95. CUP G99J21006930005.
      <div class="meta">
        <span id="status" class="pill">caricamento…</span>
        <span id="updated" class="pill"></span>
        <span id="baseline" class="pill"></span>
      </div>
    </div>

    <div class="logos">
      <!-- opzionale: se non hai loghi, puoi commentare queste 4 righe -->
      <img src="assets/italiadomani.png" alt="Italia Domani">
      <img src="assets/masaf.png" alt="MASAF">
      <img src="assets/nextgenerationeu.png" alt="NextGenerationEU">
      <img src="assets/consorzio.png" alt="Consorzio">
    </div>
  </div>
</header>

<div id="map"></div>

<div class="overlay" id="overlay">
  <div class="overlay-header">
    <div class="h">Avanzamento per tronco</div>
    <div class="controls">
      <select id="filterTronco">
        <option value="">Tutti i tronchi</option>
      </select>
      <select id="filterDitta">
        <option value="">Tutte le ditte</option>
      </select>
      <button id="resetFilters">Reset</button>
      <button id="toggle">Nascondi</button>
    </div>
  </div>
  <div class="overlay-body">
    <table>
      <thead>
        <tr>
          <th>Tronco</th>
          <th>Ditta</th>
          <th>Tot (m)</th>
          <th>Posati (m)</th>
          <th>%</th>
          <th>Δ% dal 27/01</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>
</div>

<script>
(() => {
  // ===== Config =====
  const FILE_TRONCHI = "tronchi.geojson";
  const FILE_AVANZ   = "avanzamento.json";

  // Se il 100% ti va nel verso sbagliato, lascia true
  const REVERSE_PROGRESS = true;

  // Ordine richiesto tabella + legenda colori
  const TRONCHI_ORDER = ["PV","1","2","3-1","3-2","4","5"];
  const PALETTE = ["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#a65628","#f781bf","#999999"];

  // Anti-cache
  const CB = Date.now();

  // ===== DOM =====
  const statusEl   = document.getElementById("status");
  const updatedEl  = document.getElementById("updated");
  const baselineEl = document.getElementById("baseline");
  const tbody      = document.getElementById("tbody");
  const overlay    = document.getElementById("overlay");
  const toggleBtn  = document.getElementById("toggle");
  const filterTr   = document.getElementById("filterTronco");
  const filterDi   = document.getElementById("filterDitta");
  const resetBtn   = document.getElementById("resetFilters");

  const setStatus   = (t) => statusEl.textContent = t;
  const setUpdated  = (t) => updatedEl.textContent = t;
  const setBaseline = (t) => baselineEl.textContent = t;

  // ===== Map + basemap switch =====
  const map = L.map("map");

  const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "&copy; OpenStreetMap contributors"
  });

  const carto = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
    attribution: "&copy; OpenStreetMap contributors & CARTO"
  });

  const esriSat = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    { attribution: "Tiles &copy; Esri" }
  );

  carto.addTo(map);

  L.control.layers(
    { "Carto Light": carto, "OpenStreetMap": osm, "Satellitare (Esri)": esriSat },
    {},
    { collapsed: true }
  ).addTo(map);

  // ===== Helpers =====
  const getTroncoId = (p) => p?.tronco ?? p?.Tronco ?? p?.TRONCO ?? null;
  const getDitta    = (p) => p?.ditta ?? p?.Ditta ?? p?.DITTA ?? "";

  const fmt = (n) => (Number(n) || 0).toFixed(2);

  function orderIndex(id){
    const i = TRONCHI_ORDER.indexOf(String(id));
    return i === -1 ? 999 : i;
  }
  function colorForTronco(id){
    const idx = Math.max(0, orderIndex(String(id)));
    return PALETTE[idx % PALETTE.length];
  }

  // sanitize coordinate to numbers (evita turf crash)
  function toValidPoint(pt){
    if(!Array.isArray(pt) || pt.length < 2) return null;
    const lng = Number(pt[0]), lat = Number(pt[1]);
    if(!Number.isFinite(lng) || !Number.isFinite(lat)) return null;
    return [lng, lat];
  }
  function sanitizeFeature(f){
    const g = f?.geometry;
    if(!g) return null;

    if(g.type === "LineString"){
      const clean = (g.coordinates||[]).map(toValidPoint).filter(Boolean);
      if(clean.length < 2) return null;
      return { ...f, geometry:{ type:"LineString", coordinates: clean } };
    }

    if(g.type === "MultiLineString"){
      const parts = (g.coordinates||[])
        .map(line => (line||[]).map(toValidPoint).filter(Boolean))
        .filter(line => line.length >= 2);
      if(parts.length < 1) return null;
      return { ...f, geometry:{ type:"MultiLineString", coordinates: parts } };
    }
    return null;
  }

  // Punto avanzamento
  function progressPoint(feature, done, tot){
    const perc = (tot > 0) ? Math.min(done/tot, 1) : 0;
    const totalKm = turf.length(feature, {units:"kilometers"});
    if(!Number.isFinite(totalKm) || totalKm <= 0) return { ok:false, perc };

    const eff = REVERSE_PROGRESS ? (1 - perc) : perc;
    const distKm = totalKm * eff;

    try{
      const pt = turf.along(feature, distKm, {units:"kilometers"});
      return { ok:true, perc, point: pt };
    }catch(e){
      return { ok:false, perc };
    }
  }

  // Segmenti: posato (tratteggio) e residuo (pieno) SENZA sovrapposizione
  function splitSegments(feature, done, tot){
    const totalKm = turf.length(feature, { units:"kilometers" });
    if(!Number.isFinite(totalKm) || totalKm <= 0 || tot <= 0) return { segPosato:null, segResiduo:null };

    const perc = Math.min(done / tot, 1);
    const doneKm = totalKm * perc;

    try{
      if(!REVERSE_PROGRESS){
        return {
          segPosato:  turf.lineSliceAlong(feature, 0, doneKm, { units:"kilometers" }),
          segResiduo: turf.lineSliceAlong(feature, doneKm, totalKm, { units:"kilometers" })
        };
      }else{
        return {
          segPosato:  turf.lineSliceAlong(feature, Math.max(totalKm - doneKm, 0), totalKm, { units:"kilometers" }),
          segResiduo: turf.lineSliceAlong(feature, 0, Math.max(totalKm - doneKm, 0), { units:"kilometers" })
        };
      }
    }catch(e){
      return { segPosato:null, segResiduo:null };
    }
  }

  // ===== Overlay toggle =====
  let hidden = false;
  toggleBtn.addEventListener("click", () => {
    hidden = !hidden;
    overlay.style.height = hidden ? "44px" : "";
    overlay.querySelector(".overlay-body").style.display = hidden ? "none" : "block";
    toggleBtn.textContent = hidden ? "Mostra" : "Nascondi";
  });

  // ===== State for filtering =====
  const layersByTronco = {}; // id -> [layers...]
  let rowsData = [];         // [{id,ditta,tot,done,perc,col,feature}]
  let baseDate = "";
  let baseMap = {};

  function clearLayers(){
    Object.values(layersByTronco).forEach(arr => arr.forEach(l => map.removeLayer(l)));
    Object.keys(layersByTronco).forEach(k => delete layersByTronco[k]);
  }

  function buildFilters(){
    const ids = Array.from(new Set(rowsData.map(r => r.id)))
      .sort((a,b) => orderIndex(a) - orderIndex(b) || a.localeCompare(b));

    filterTr.innerHTML = `<option value="">Tutti i tronchi</option>` +
      ids.map(id => `<option value="${id}">${id}</option>`).join("");

    const ditte = Array.from(new Set(rowsData.map(r => r.ditta).filter(Boolean))).sort();
    filterDi.innerHTML = `<option value="">Tutte le ditte</option>` +
      ditte.map(d => `<option value="${d}">${d}</option>`).join("");
  }

  function renderTable(filtered){
    tbody.innerHTML = "";

    filtered.forEach(r => {
      const baseDone = Number(baseMap[r.id] ?? 0);
      const deltaM = r.done - baseDone;
      const deltaPerc = (r.tot > 0) ? (deltaM / r.tot) * 100 : 0;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><span class="swatch" style="background:${r.col}"></span>${r.id}</td>
        <td>${r.ditta || ""}</td>
        <td>${fmt(r.tot)}</td>
        <td>${fmt(r.done)}</td>
        <td>
          ${r.perc.toFixed(1)}%
          <div class="bar"><div style="width:${Math.min(r.perc,100).toFixed(1)}%"></div></div>
        </td>
        <td>${deltaPerc.toFixed(1)}%</td>
      `;
      tbody.appendChild(tr);
    });
  }

  function applyFilters(){
    const t = filterTr.value;
    const d = filterDi.value;

    const filtered = rowsData.filter(r => {
      const okT = !t || r.id === t;
      const okD = !d || r.ditta === d;
      return okT && okD;
    });

    // tabella
    renderTable(filtered);

    // mappa: mostra solo tronchi filtrati
    const visibleIds = new Set(filtered.map(r => r.id));
    Object.entries(layersByTronco).forEach(([id, arr]) => {
      const show = visibleIds.has(id);
      arr.forEach(layer => {
        if(show){
          if(!map.hasLayer(layer)) layer.addTo(map);
        }else{
          if(map.hasLayer(layer)) map.removeLayer(layer);
        }
      });
    });
  }

  filterTr.addEventListener("change", applyFilters);
  filterDi.addEventListener("change", applyFilters);
  resetBtn.addEventListener("click", () => {
    filterTr.value = "";
    filterDi.value = "";
    applyFilters();
  });

  // ===== Load =====
  setStatus("caricamento…");

  Promise.all([
    fetch(FILE_TRONCHI + "?cb=" + CB).then(r => { if(!r.ok) throw new Error("tronchi.geojson HTTP " + r.status); return r.json(); }),
    fetch(FILE_AVANZ   + "?cb=" + CB).then(r => { if(!r.ok) throw new Error("avanzamento.json HTTP " + r.status); return r.json(); })
  ])
  .then(([geo, avanz]) => {

    setStatus("dati caricati");
    setUpdated("aggiornato: " + (avanz._updated || "NON INDICATO nel JSON"));

    baseDate = avanz._baseline_date || "2026-01-27";
    baseMap  = avanz._baseline_done || {};
    setBaseline("baseline: " + baseDate);

    const cleanFeatures = (geo.features || []).map(sanitizeFeature).filter(Boolean);

    // dataset (1 riga per feature/tronco)
    rowsData = [];
    cleanFeatures.forEach(f => {
      const id = getTroncoId(f.properties);
      if(!id) return;

      const dati = avanz[String(id)];
      if(!dati) return;

      const ditta = getDitta(f.properties);
      const tot = Number(dati.tot) || 0;
      const done = Number(dati.done) || 0;
      const perc = tot > 0 ? (done/tot)*100 : 0;
      const col = colorForTronco(id);

      rowsData.push({ id:String(id), ditta, tot, done, perc, col, feature:f });
    });

    // sort PV,1,2,3-1,3-2,4,5
    rowsData.sort((a,b) => orderIndex(a.id) - orderIndex(b.id) || a.id.localeCompare(b.id));

    // Fit bounds su tutte le geometrie
    const tmp = L.geoJSON({type:"FeatureCollection", features: cleanFeatures}).addTo(map);
    if(cleanFeatures.length) map.fitBounds(tmp.getBounds());
    map.removeLayer(tmp);

    // Disegno layer (una sola volta)
    clearLayers();

    rowsData.forEach(r => {
      const id = r.id;
      const f = r.feature;
      const col = r.col;
      const ditta = r.ditta;

      layersByTronco[id] = layersByTronco[id] || [];

      const { segPosato, segResiduo } = splitSegments(f, r.done, r.tot);

      // residuo pieno (da fare)
      if(segResiduo){
        const layerResiduo = L.geoJSON(segResiduo, {
          style: { color: col, weight: 5, opacity: 1 }
        });
        layerResiduo.addTo(map);
        layersByTronco[id].push(layerResiduo);
      }

      // posato tratteggiato
      if(segPosato){
        const layerPosato = L.geoJSON(segPosato, {
          style: { color: col, weight: 5, opacity: 1, dashArray: "10 8" }
        });
        layerPosato.addTo(map);
        layersByTronco[id].push(layerPosato);
      }

      // punto avanzamento
      const res = progressPoint(f, r.done, r.tot);
      if(res.ok && res.point){
        const [lng, lat] = res.point.geometry.coordinates;
        const p = L.circleMarker([lat, lng], {
          radius: 7, color: col, fillColor: col, fillOpacity: 1
        }).bindPopup(`
          <b>Tronco ${id}</b><br>
          ${ditta ? `<i>${ditta}</i><br>` : ""}
          ${fmt(r.done)} / ${fmt(r.tot)} m<br>
          ${(Math.min(r.done / (r.tot||1), 1)*100).toFixed(1)} %
        `);
        p.addTo(map);
        layersByTronco[id].push(p);
      }
    });

    // filtri + prima render
    buildFilters();
    applyFilters();
  })
  .catch(err => {
    console.error(err);
    setStatus("errore");
    alert(err.message || "Errore nel caricamento");
  });

})();
</script>
</body>
</html>
